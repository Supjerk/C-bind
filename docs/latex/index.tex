Function binding in C !!!

\section*{How to use}

\subsection*{Invocation}

To invoke the bound version of {\ttfamily my\+\_\+func}, one could simply invoke it as 
\begin{DoxyCode}
bound\_func( arg1, arg2, arg3 )
\end{DoxyCode}
 {\itshape Despite the odd function signature of the function to be bound, it can be invoked like a standard function.} Note, if you pass extra unexpected arguments to {\ttfamily bound\+\_\+func} they will be ignored.

\subsection*{Signature}

Functions to be bound must have a unique signature, however when calling them they may be called as standard functions. To bind a function, it must have the following signature\+: 
\begin{DoxyCode}
\textcolor{keywordtype}{void} * my\_func( \textcolor{keywordtype}{void} ** args )
\end{DoxyCode}
 The return value may simply be any other primitive so you cast it properly during the binding call. You can think of {\ttfamily args} as an array of arguments! Parsing the {\ttfamily args} array is the job of {\ttfamily my\+\_\+func}. {\ttfamily my\+\_\+func} must have a defined maximum number of \textquotesingle{}arguments\textquotesingle{}. {\itshape That is, {\ttfamily my\+\_\+func} must expect that no more {\ttfamily num\+\_\+args} number of elements in the {\ttfamily args} array to be passed.}

\subsection*{Fully binding}

To fully bind a functon, invoke 
\begin{DoxyCode}
bound\_func = \hyperlink{bind_8c_aba8492ffd71864427a5cddc0c3888454}{full\_bind}( my\_func, num\_args, arg1, arg2, arg3 )
\end{DoxyCode}
 Here {\ttfamily num\+\_\+args} is the number of elements in the {\ttfamily args} array {\ttfamily my\+\_\+func} expects to be passed. Notice that if you pass in more arguments {\ttfamily num\+\_\+args} they will be ignored.

\#\#\# Example 
\begin{DoxyCode}
\textcolor{comment}{// This function expects exactly 1 argument!}
\textcolor{keywordtype}{void} * id( \textcolor{keywordtype}{void} ** args ) \{ \textcolor{keywordflow}{return} args[0]; \}
bound\_func = \hyperlink{bind_8c_aba8492ffd71864427a5cddc0c3888454}{full\_bind}( \textcolor{keywordtype}{id}, 1, \textcolor{comment}{/* Arguments begin */} 0x41414141 );
printf( \textcolor{stringliteral}{"My id = %d\(\backslash\)n"}, (\textcolor{keywordtype}{int}) bound\_func() );  \textcolor{comment}{// Prints out 0x41414141}
\end{DoxyCode}


\subsubsection*{Partial binding}

To partially bind a function, invoke 
\begin{DoxyCode}
bound\_func = \hyperlink{bind_8c_a749a103d16b748b8aecff011472a0881}{partial\_bind}( my\_func, num\_args, num\_args\_to\_bind, arg1, arg2 );
\end{DoxyCode}
 Here {\ttfamily num\+\_\+args\+\_\+to\+\_\+bind} is the number of arguments currently being bound!

\#\#\# Example 
\begin{DoxyCode}
\textcolor{comment}{// This function expects exactly 3 arguments}
\textcolor{keywordtype}{void} * sum3( \textcolor{keywordtype}{void} ** args ) \{ \textcolor{keywordflow}{return} args[0] + args[1] + args[2]; \}
bound\_func = \hyperlink{bind_8c_a749a103d16b748b8aecff011472a0881}{partial\_bind}( sum3, 3, 2, \textcolor{comment}{/* Arguments begin */} 100, 200 );
printf( \textcolor{stringliteral}{"Total sum = %d\(\backslash\)n"}, (\textcolor{keywordtype}{int}) bound\_func(300) );  \textcolor{comment}{// Prints out 600}
\end{DoxyCode}


\subsection*{Thread Safety}

Yes, after the first bind. \+:)

\subsection*{How to test}

To test that this works\+: 
\begin{DoxyCode}
1 git clone https://github.com/zwimer/C-bind && \(\backslash\)
2 mkdir C-bind/src/build && cd C-bind/src/build && \(\backslash\)
3 cmake .. && make && \(\backslash\)
4 ./test.out
\end{DoxyCode}


\section*{Documentation}

Documentation is stored in {\ttfamily ./docs}, it is generated via \href{http://www.doxygen.nl/}{\tt doxygen}. To manually generate it install doxygen (from {\ttfamily apt-\/get} if you have it) then 
\begin{DoxyCode}
1 cd C-bind && doxygen
\end{DoxyCode}


\section*{Future Plans}

\subsubsection*{Removing the signature requirement}

By emulating the {\ttfamily x86\+\_\+64} calling convention I can remove the requirement of needing that special signature to bind a functon.

\subsubsection*{Memory efficiency}

Right now the {\ttfamily get\+\_\+stub} function maps an entire page of memory per stub generated. Realistically it should only require just a few bytes. This can be done by placing multiple stub functions on the same page.

\section*{Restrictions}

Currently this only works on 64-\/bit {\ttfamily x86}. 